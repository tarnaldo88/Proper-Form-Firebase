rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // User profiles
    match /users/{userId} {
      // Users can read/write their own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Public profile fields can be read by any authenticated user
      match /public {
        allow read: if request.auth != null;
      }

      // Friends subcollection
      match /friends/{friendId} {
        // Users can manage their own friends list
        allow read, create, delete: if request.auth != null && request.auth.uid == userId;
        
        // Validate friend request data
        allow create: if request.resource.data.keys().hasAll(['friendId', 'status', 'timestamp'])
                   && request.resource.data.friendId is string
                   && request.resource.data.status in ['pending', 'accepted', 'rejected']
                   && request.resource.data.timestamp is timestamp;
      }

      // Messages subcollection
      match /messages/{messageId} {
        // Users can read and write their own messages
        allow read, create: if request.auth != null && 
                           (request.auth.uid == userId || 
                            request.auth.uid == resource.data.senderId ||
                            request.auth.uid == resource.data.recipientId);
                            
        // Only allow updating the 'read' field
        allow update: if request.auth != null &&
                      request.auth.uid == userId &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
                      
        // Validate message data
        allow create: if request.resource.data.keys().hasAll(['senderId', 'recipientId', 'content', 'timestamp', 'read'])
                   && request.resource.data.senderId is string
                   && request.resource.data.recipientId is string
                   && request.resource.data.content is string
                   && request.resource.data.timestamp is timestamp
                   && request.resource.data.read is bool;
      }

      // Competitions subcollection
      match /competitions/{competitionId} {
        // Users can read competitions they're part of
        allow read: if request.auth != null && 
                   (request.auth.uid == userId || 
                    resource.data.participants.hasAny([request.auth.uid]));
                    
        // Users can create new competitions
        allow create: if request.auth != null && 
                     request.auth.uid == userId &&
                     request.resource.data.keys().hasAll(['name', 'description', 'startDate', 'endDate', 'participants', 'createdBy'])
                     && request.resource.data.createdBy == userId
                     && request.resource.data.participants.hasAny([userId]);
                     
        // Only competition creator can update certain fields
        allow update: if request.auth != null &&
                      request.auth.uid == resource.data.createdBy &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'endDate', 'winners']);
      }
    }
    
    // Public competitions collection
    match /public_competitions/{competitionId} {
      // Anyone can read public competitions
      allow read: if request.auth != null;
      
      // Only authenticated users can create public competitions
      allow create: if request.auth != null &&
                    request.resource.data.keys().hasAll(['name', 'description', 'startDate', 'endDate', 'createdBy'])
                    && request.resource.data.createdBy == request.auth.uid;
    }
    
    // Leaderboards collection
    match /leaderboards/{leaderboardId} {
      // Anyone can read leaderboards
      allow read: if request.auth != null;
      
      // Only server can update leaderboards
      allow write: if false; // Disabled - should be updated via Cloud Functions
    }
  }
}
